use std::collections::HashMap;

use serde::Deserialize;
use serde::Serialize;
use tvm_block::HashmapAugType;
use typed_builder::TypedBuilder;

use crate::repository::optimistic_state::DAppIdTable;
use crate::repository::optimistic_state::OptimisticState;
use crate::repository::optimistic_state::OptimisticStateImpl;
use crate::types::account::WrappedAccount;
use crate::types::AccountRouting;
use crate::types::AckiNackiBlock;
use crate::types::BlockIdentifier;
use crate::types::BlockSeqNo;
use crate::types::ThreadIdentifier;
use crate::types::ThreadsTable;

pub type Message = crate::message::WrappedMessage;

/// This structure has to have minimum and complete data required
/// for other threads to reference a state at a particular block.
#[derive(TypedBuilder, Clone, Serialize, Deserialize)]
pub struct CrossThreadRefData {
    block_identifier: BlockIdentifier,
    block_seq_no: BlockSeqNo,
    block_thread_id: ThreadIdentifier,
    dapp_id_table: DAppIdTable,
    // This stores outbound messages for THIS block only. It does not aggregate
    // this info over multiple blocks.
    // TODO: research possible optimizations: we don't have to store messages, seems better to have
    // cell instead. And key is not used now, but it can be used in case of cell value
    outbound_messages: HashMap<AccountRouting, Vec<Message>>,
    outbound_accounts: HashMap<AccountRouting, WrappedAccount>,
    threads_table: ThreadsTable,
    parent_block_id: BlockIdentifier,
    block_refs: Vec<BlockIdentifier>,
}

impl CrossThreadRefData {
    pub fn as_reference_state_data(&self) -> (ThreadIdentifier, BlockIdentifier, BlockSeqNo) {
        (self.block_thread_id, self.block_identifier.clone(), self.block_seq_no)
    }

    pub fn from_ackinacki_block(
        block: &AckiNackiBlock,
        optimistic_state: &mut OptimisticStateImpl,
    ) -> anyhow::Result<Self> {
        // TODO: in fact we crop state here but take the removed part. It would be better to optimize it
        let mut outbound_messages: HashMap<AccountRouting, Vec<Message>> = HashMap::new();
        assert!(block
            .tvm_block()
            .read_extra()
            .map_err(|e| anyhow::anyhow!("Failed to read block extra: {:?}", e))?
            .read_out_msg_descr()
            .map_err(|e| anyhow::anyhow!("Failed to read block out msg descr: {:?}", e))?
            .iterate_objects(|out_msg| {
                // None value is not expected to be here, but possibly it can be generated by TVM,
                // so use this condition.
                if let Some(message) = out_msg.read_message()? {
                    // Parse only messages with internal destination
                    if let Some(destination) = message.int_dst_account_id() {
                        let destination = optimistic_state
                            .get_account_routing(&destination)
                            .map_err(|_e| tvm_types::error!("Failed to get destination routing"))?;
                        if !optimistic_state
                            .does_routing_belong_to_the_state(&destination)
                            .map_err(|_e| {
                                tvm_types::error!("Failed to check message destination")
                            })?
                        {
                            let messages = outbound_messages.entry(destination).or_default();
                            messages.push(crate::message::WrappedMessage { message });
                        }
                    }
                }
                Ok(true)
            })
            .map_err(|e| anyhow::anyhow!("Failed to read block extra: {:?}", e))?);
        let mut outbound_accounts: HashMap<AccountRouting, WrappedAccount> = HashMap::new();
        let accounts = optimistic_state
            .get_shard_state()
            .read_accounts()
            .map_err(|e| anyhow::format_err!("Failed to read shard state accounts: {e}"))?;
        assert!(accounts
            .iterate_objects(|shard_account| {
                let account = shard_account.read_account()?;
                let account_routing = optimistic_state
                    .get_account_routing(&account.get_id().expect("Account should not be none"))
                    .map_err(|_e| tvm_types::error!("Failed to get account routing"))?;
                if !optimistic_state
                    .does_routing_belong_to_the_state(&account_routing)
                    .map_err(|_e| tvm_types::error!("Failed to check message destination"))?
                {
                    outbound_accounts
                        .insert(account_routing, WrappedAccount { account: shard_account });
                }
                Ok(true)
            })
            .map_err(|e| anyhow::format_err!("Failed to iterate accounts: {e}"))?);
        Ok(Self {
            block_identifier: block.identifier().clone(),
            dapp_id_table: optimistic_state.dapp_id_table.clone(),
            outbound_messages,
            outbound_accounts,
            threads_table: optimistic_state.threads_table.clone(),
            block_seq_no: optimistic_state.block_seq_no,
            block_thread_id: optimistic_state.thread_id,
            parent_block_id: block.parent(),
            block_refs: block.get_common_section().refs.clone(),
        })
    }

    pub fn block_identifier(&self) -> &BlockIdentifier {
        &self.block_identifier
    }

    pub fn block_seq_no(&self) -> &BlockSeqNo {
        &self.block_seq_no
    }

    // This is an identifier of the block thread (An input state to generate this data)
    pub fn block_thread_identifier(&self) -> &ThreadIdentifier {
        &self.block_thread_id
    }

    pub fn dapp_id_table(&self) -> &DAppIdTable {
        &self.dapp_id_table
    }

    pub fn get_produced_threads_table(&self) -> &ThreadsTable {
        &self.threads_table
    }

    pub fn parent_block_identifier(&self) -> &BlockIdentifier {
        &self.parent_block_id
    }

    pub fn refs(&self) -> &Vec<BlockIdentifier> {
        &self.block_refs
    }

    // This block produced a table that requires new threads to be spawned
    pub fn spawned_threads(&self) -> Vec<ThreadIdentifier> {
        let mut threads: Vec<ThreadIdentifier> = self.threads_table.rows().map(|e| e.1).collect();
        threads.retain(|e| e.is_spawning_block(&self.block_identifier));
        threads
    }

    /// This method filters outbound messages of THIS block only.
    /// It does not include messages generated in previous blocks.
    pub fn select_cross_thread_messages<F>(
        &self,
        // Function that returns True for messages that should be included
        // to the result. False otherwise.
        mut filter: F,
    ) -> std::vec::Vec<Message>
    where
        F: FnMut(&Message) -> bool,
    {
        let mut filtered_messages = vec![];
        for messages in self.outbound_messages.values() {
            // TODO: Remake internal field and this function
            if messages.is_empty() {
                continue;
            }
            if filter(&messages[0]) {
                filtered_messages.extend_from_slice(messages);
            }
        }
        filtered_messages
    }

    pub fn select_cross_thread_accounts<F>(
        &self,
        // Function that returns True for messages that should be included
        // to the result. False otherwise.
        mut filter: F,
    ) -> std::vec::Vec<WrappedAccount>
    where
        F: FnMut(&AccountRouting) -> bool,
    {
        let mut filtered_accounts = vec![];
        for (routing, account) in &self.outbound_accounts {
            if filter(routing) {
                filtered_accounts.push(account.clone());
            }
        }
        filtered_accounts
    }
}
